
const questions = [
  {
    id: 1,
    alredyAnswerd: false,
    question: 'Що таке замикання (closure) в JavaScript?',
    options: [
      'Функція, яка приймає іншу функцію як аргумент.',
      'Об\'єкт, який зберігає дані і методи.',
      'Змінна, яка зберігає посилання на функцію поза її областю видимості.'
    ],
    correctAnswer: 'Змінна, яка зберігає посилання на функцію поза її областю видимості.',
    multipleAnswer: false
  },
  {
    id: 2,
    alredyAnswerd: false,
    question: 'Що спричиняє створення замикання в JavaScript?',
    options: [
      'Використання ключового слова `this` в середині функції.',
      'Збереження посилання на функцію поза її областю видимості.',
      'Використання класів та об\'єктів.'
    ],
    correctAnswer: 'Збереження посилання на функцію поза її областю видимості.',
    multipleAnswer: false
  },
  {
    id: 3,
    alredyAnswerd: false,
    question: ' Для чого можна використовувати замикання в JavaScript?',
    options: [
      'Для зберігання інформації про об\'єкти та їх властивості.',
      'Для огортування коду і забезпечення видимості змінних.',
      'Для підрахунку математичних операцій.'
    ],
    correctAnswer: 'Для огортування коду і забезпечення видимості змінних.',
    multipleAnswer: false
  },
  {
    id: 4,
    alredyAnswerd: false,
    question: 'Що таке асинхронність в JavaScript?',
    options: [
      'Можливість виконувати кілька функцій одночасно на різних потоках.',
      'Стиль програмування, який передбачає виключно синхронний код.',
      'Можливість виконувати декілька операцій одночасно без блокування основного потоку.'
    ],
    correctAnswer: 'Можливість виконувати декілька операцій одночасно без блокування основного потоку.',
    multipleAnswer: false
  },
  {
    id: 5,
    alredyAnswerd: false,
    question: 'Що таке колбеки (callbacks) в асинхронному JavaScript?',
    options: [
      'Функції, які викликаються з помилкою при асинхронному коді.',
      'Спеціальні об\'єкти для відстеження прогресу виконання асинхронних операцій.',
      'Функції, які передаються в іншу функцію для виконання після завершення асинхронної операції.'
    ],
    correctAnswer: 'Функції, які передаються в іншу функцію для виконання після завершення асинхронної операції.',
    multipleAnswer: false
  },
  {
    id: 6,
    alredyAnswerd: false,
    question: ' Що таке Promise  в JavaScript?',
    options: [
      'Стандартний об\'єкт для зберігання промісів із значеннями.',
      'Спеціальний тип змінної, який може містити асинхронний код.',
      'Механізм для представлення потенційного результату асинхронної операції.'
    ],
    correctAnswer: 'Механізм для представлення потенційного результату асинхронної операції.',
    multipleAnswer: false
  },
  {
    id: 7,
    alredyAnswerd: false,
    question: ' Що таке async/await в JavaScript?',
    options: [
      'Оператори для зберігання результатів асинхронних операцій у змінних.',
      'Спеціальний синтаксис для виконання декількох асинхронних операцій одночасно.',
      'Синтаксис для більш зручного написання асинхронного коду на основі промісів.'
    ],
    correctAnswer: 'Синтаксис для більш зручного написання асинхронного коду на основі промісів.',
    multipleAnswer: false
  },
  {
    id:8,
    alredyAnswerd: false,
    question: 'Що таке Event Loop в JavaScript?',
    options: [
      'Механізм, який використовується для обробки різних типів подій у веб-додатках.',
      'Механізм, який забезпечує асинхронне виконання функцій у JavaScript.',
      'Механізм, який керує порядком виконання завдань у черзі і забезпечує виконання подій у правильному порядку.'
    ],
    correctAnswer: 'Механізм, який керує порядком виконання завдань у черзі і забезпечує виконання подій у правильному порядку.',
    multipleAnswer: false
  },
  {
    id: 9,
    alredyAnswerd: false,
    question: ' Що таке виключення (exception) в JavaScript?',
    options: [
      'Об\'єкт, який містить значення помилки та контекст її виникнення.',
      'Особливий тип даних, який зберігає інформацію про поточний стан програми.',
      'Процес, за допомогою якого JavaScript перехоплює та виправляє помилки автоматично.'
    ],
    correctAnswer: 'Об\'єкт, який містить значення помилки та контекст її виникнення.',
    multipleAnswer: false
  },
  {
    id: 10,
    alredyAnswerd: false,
    question: ' Яким чином можна обробити виключення в JavaScript?',
    options: [
      'За допомогою конструкції `try-catch`.',
      'Перевіряючи наявність виключення за допомогою умовних операторів.',
      'За допомогою функції `throw` для генерації нового виключення.'
    ],
    correctAnswer: 'За допомогою конструкції `try-catch`.',
    multipleAnswer: false

  },
  {
    id: 11,
    alredyAnswerd: false,
    question: 'Які переваги використання обробки виключень в JavaScript?',
    options: [
      'Дозволяє перенести виключення на вищий рівень коду для зручнішого управління помилками.',
      'Пришвидшує виконання коду, уникнувши перевірки на помилки.',
      'Дозволяє автоматично виправляти помилки у коді.'
    ],
    correctAnswer: 'Дозволяє перенести виключення на вищий рівень коду для зручнішого управління помилками.',
    multipleAnswer: false

  },
  {
    id: 12,
    question: 'Які методи можна використовувати для обробки асинхронного коду в JavaScript?',
    options: [
        'Callbacks',
        'Promises',
        'Async/await',
        'Event Emitters',
        'Generators'
    ],
    correctAnswer: ['Callbacks',
    'Promises',
    'Async/await',
    'Event Emitters',
    'Generators'],
    multipleAnswer: true
},
{
  id: 13,
  question: 'Що таке Event Loop?',
  options: [
      'Це петля, яка виконує JavaScript код безперервно.',
      'Це частина мови JavaScript для роботи з подіями.',
      'Це механізм, який дозволяє асинхронно виконувати код.',
      'Це алгоритм для роботи з масивами.',
      'Event Loop відсутній в JavaScript.'
  ],
  correctAnswer: [ 'Це петля, яка виконує JavaScript код безперервно.', 'Це механізм, який дозволяє асинхронно виконувати код.',
  'Це алгоритм для роботи з масивами.',],
  multipleAnswer: true
},
{
  id: 14,
  question: 'Якими методами можна комбінувати декілька промісів та отримувати результат, коли всі проміси виконані?',
  options: [
      'Promise.all',
      'Promise.race',
      'Promise.any',
      'Promise.resolve'
  ],
  correctAnswer: ['Promise.all',
  'Promise.race',
  'Promise.any',], 
  multipleAnswer: true
},
{
  id:15,
  multipleAnswer: true,
  question: 'Які можливості надає замикання в JavaScript?',
  options: [
      'Замикання дозволяють створювати приватні змінні і функції в межах іншої функції.',
      'Замикання дозволяють використовувати проміси для асинхронного коду.',
      'Замикання забезпечують швидший виконання коду.',
      'Замикання є альтернативою використанню класів для об\'єктно-орієнтованого програмування.',
      'Замикання дозволяють визначати глобальні змінні.'
  ],
  correctAnswer: ['Замикання дозволяють створювати приватні змінні і функції в межах іншої функції.', 'Замикання є альтернативою використанню класів для об\'єктно-орієнтованого програмування.',] // Правильні відповіді - 1, 4
},
{
  id: 16,
  multipleAnswer: true,
  question: 'Як використовувати замикання для створення "фабричних" функцій?',
  options: [
      'Створити новий клас із фабричним методом.',
      'Створити анонімну функцію з декількома вкладеними замиканнями.',
      'Створити функцію, яка повертає іншу функцію із параметрами.',
      'Використовувати оператор new для створення екземпляра фабричного об\'єкта.',
      'Створити глобальний об\'єкт з фабричними методами.'
  ],
  correctAnswer: [ 'Створити анонімну функцію з декількома вкладеними замиканнями.',
  'Створити функцію, яка повертає іншу функцію із параметрами.'] 
},
{
  id: 17, 
  multipleAnswer: true,
  question: 'Які можливості надає замикання в JavaScript?',
  options: [
      'Замикання дозволяють створювати приватні змінні і функції в межах іншої функції.',
      'Замикання дозволяють використовувати проміси для асинхронного коду.',
      'Замикання забезпечують швидший виконання коду.',
      'Замикання є альтернативою використанню класів для об\'єктно-орієнтованого програмування.',
      'Замикання дозволяють визначати глобальні змінні.'
  ],
  correctAnswer: ['Замикання дозволяють створювати приватні змінні і функції в межах іншої функції.', 'Замикання є альтернативою використанню класів для об\'єктно-орієнтованого програмування.',],
},
{
  id: 17,
  question: 'Як використовувати замикання для створення "фабричних" функцій?',
  options: [
      'Створити новий клас із фабричним методом.',
      'Створити анонімну функцію з декількома вкладеними замиканнями.',
      'Створити функцію, яка повертає іншу функцію із параметрами.',
      'Використовувати оператор new для створення екземпляра фабричного об\'єкта.',
      'Створити глобальний об\'єкт з фабричними методами.'
  ],
  correctAnswer: ['Створити анонімну функцію з декількома вкладеними замиканнями.',
  'Створити функцію, яка повертає іншу функцію із параметрами.',], 
  multipleAnswer: true
},
{
  id: 18, 
  question: `Який код використовується для створення власного виняткового класу в JavaScript?
  
  class CustomError extends Error {
    constructor(message) {
      super(message);
      this.name = 'CustomError';
    }
    }
    
    throw new CustomError('Це власний виняток'); `,
  options: [
      'throw new CustomError("Це власний виняток");',
      'throw CustomError("Це власний виняток");',
      'throw Error("Це власний виняток");',
      'new CustomError("Це власний виняток");',
      'new Error("Це власний виняток");'
  ],
  correctAnswer: [ 'throw new CustomError("Це власний виняток");'],
  multipleAnswer: false
},
{
  id: 19,
  question: 'Яке з вказаних тверджень є правильним для обробки винятків?',
  options: [
      'try-catch є необов\'язковою, а блок finally завжди має бути використаний.',
      'Блок finally може бути використаний тільки разом з блоком catch.',
      'try-catch є обов\'язковою, а блок finally може бути пропущений.',
      'Блок finally має бути завжди використаний разом з блоком try.'
  ],
  correctAnswer: ['try-catch є обов\'язковою, а блок finally може бути пропущений.'], 
  multipleAnswer: false
},
{
  question: 'Яка буде виведена в консоль значення після виконання наступного коду?',
  codeSnippet: `
const outer = (x) => {
const inner = (y) => {
  return x + y;
};
return inner;
};

const closureFunc = outer(10);
const result = closureFunc(5);
console.log(result);
  `,
  options: [
      '10',
      '5',
      '15',
      'undefined',
      'Помилка виконання'
  ],
  correctAnswer: ['15'], 
multipleAnswer: false
}
];

module.exports = questions